# [Codeforces Round #735 (Div. 2)](https://codeforces.com/contest/1554)

## A

显然取到最大值之后想要区间最小，因此最佳答案必然是区间长度为 2

## B

注意到 $i * j$ 可占优，因此 i 从大到小遍历不到几步就能搞出最优答案

## C

考虑二进制表达即可。首先显然 $n > m$ 时，答案为 0，然后注意到我们可以让 m 加 1 好处理一点。

从最高位开始搞起，搞完就把高位都丢掉，继续想低位处理。若 $n \geq m$ 结束。若此 $n$ 为 0，$m$ 为 1 那么说明这一位必然能取到 1


## D

注意到 $n$ 个 `a` 然后一个 b 然后 $n + 1$ 个 `a` 必然是满足条件的，如果长度不满足再加个 c

## E

> 官方题解真的妙

首先反过来想，初始时，所有点 $a_u = 0$，$u, v$ 有一条边的时候，$u, v$ 必有一个 $a_u, a_v$ 增加了 1，最终 $\sum_{i = 1}^n a_u = n - 1$，然后相当于每条边有两种选择，因此最终的情况数为 $2^{n - 1}$（注意我们并不关心顺序）

假设对每一个 $k = 1, \cdots, n$，设 $f_k = |\{ (a_1 \cdots, a_n) \mid k | a_i \}|$，显然 $f_1 = 2^{n - 1}$ 且 $f_k = 0,\; k \not \mid n - 1$。对于 $k > 1$ 的情况，我们发现任何叶子节点都不可能给值，所以我们可以删掉叶子节点得到新的值。然后对于固定的 $k$，显然我们最多只有一种选择。

做法：每个 $k$，定向的同时从底向上搞即可