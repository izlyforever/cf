## [Codeforces Round #681 (Div. 2, based on VK Cup 2019-2020 - Final)](https://codeforces.com/contest/1443)

> 把 div1 和 div2 放在一起了

## [1443D](https://codeforces.com/contest/1443/problem/D)：经典问题

给定一个非负数列，问是否可以通过前缀减一，后缀减一的方式使得所有的数都变成 0

> 一开始以为只需中间的数大于两边的最小值之和就可以，后来发现不对，然后通过自己想了一个例子，然后想到了正确做法，开心
> 这个问题等价与给定 $a$，求非负序列 $p, q$ 满足 $p + q = a$, $p$ 单调减，$q$ 单调递增（在保证条件下，使得$p$ 尽量大）

做法：看相邻两个数，比如左边比右边大，那么必然右边至少要做后缀减一的操作它们的差值次，也就是说，后面所有的数都要减去这个差值。反之同理，所以搞两个变量，一个是左边累减去（可以用剩余多少来标记），一个是右边累减。没跑一步判断一次。

## [1442D](https://codeforces.com/contest/1442/problem/D)：经典分治问题

> 首先这是一个很实在的问题。给定 $n$ 个单调递增的序列，从中取 $k$ 个数，但是取数的时候每次只能在序列的最前面取，也就是取最小的。求最大的和。首先注意最多只有一个序列取了一部分，其它的要么没取，要么取完（反证），那么我们可以二分枚举其在左边还是在右边

如果直接暴力写，也就是枚举那个只取了一部分的，其它的就是一个 `0-1` 背包，所以总复杂度为 $O(n^2 k)$，这肯定是过不了的。但是可以分治，也就是说分成两半，一半是 `0-1` 背包（即要么取完要么没取），另一半是原问题的子问题！这不就有了吗，经典！！

> 本来是每一层都是一个 `dp`，但是 [Itst](https://codeforces.com/profile/Itst) 做了空间优化
> 知道在某一个性质的点上取得最值，那么不一定要把这个点求出来，可以在一定范围内把值都比较一遍即可，因为极值点的判断有可能相对更为复杂，这可能就是计算机的魅力吧。
> 另外 [Jiangly](https://codeforces.com/contest/1442/submission/97479495) 写了一个非递归的 $\sqrt{n}$ 的做法，也很犀利。
