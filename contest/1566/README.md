# [Codeforces Global Round 16](https://codeforces.com/contest/1566)

## A

答案显然为: `s / (n - (n - 1) / 2)`

## B

直接贪心，看有几段 0，当然了答案不会超过 2

## C

这个也是贪心
- 注意到如果一列正好 0, 1 都有那么直接答案 +2，然后如果前面有 0 的列，那么答案再 +1
- 否则看两列的情况，两列都是 1，那么直接无视看作一列 1，如果两列都是 0，视作一列 0，并且答案 +1
- 如果两列不同，答案直接 +2
- 最后如果还有一列 0 在的话，答案 +1

## D

首先正常排序，然后就可以变成一行行的解决了，对于每一行，可以对下标先离散化一下，然后用树状数组更新结果，对于每一个如果两个值相等，肯定是编号小的放后面比较赚

## E

注意到我们每次割边之后，可以放在根上先暂时放着，然后我们就可以开心的割了，对每一个节点 u，它的儿子节点 v，如果 v 只有它自己，那它就必须跟 u 连在一起，否则他们就要分离，假设 u 有 x 个儿子最后跟它在一起(x > 0)，那么它对答案的贡献就为 $x - 1$

## F

- 剔除掉包含其他区间的区间
- 剔除已经包含节点的区间
- 各个节点必然不会碰到一起
- 假设某个节点确定了要访问一些区间，那么它的代价为 $2 \min(a, b) + \max(a, b)$, 其中 $a, b$ 分别为到左边和右边的最远距离
- 第 $i$ 和 $i + 1$ 个节点中间出现的区间必然只被他们访问，且一左一右的被他们瓜分
- 因为我们可以设 `dp[i][j]` 为第 $i$ 个节点，右边还有 $j$ 个区间的答案，那么显然我们有状态转移

$$
dp[i][j] = \min_{0 \leq x \leq k} dp[i - 1][k] + 2 * \min(b_{i, j}, a_{i, k}) + \max(b_{i, j}, a_{i, k})
$$

其中 $b_{i, j}$ 为第 $i$ 个节点和它之后的 $j$ 个区间的距离，$a_{i, k}$ 为 $i - 1$ 个节点之后 $k + 1$ 个区间和第 $i$ 个节点之间的距离

然后我们可以通过找到 $a_{i, k} \leq b_{i, j} \leq a_{i, k - 1}$ 的位置（可以二分，但是没必要）

那么前半部分的转移方程为

$$
dp[i][j] = \min_{0 \leq x \leq k} dp[i - 1][k] + x_i - r_{k + 1} + 2 b_{i, j}
$$

那么后半部分的转移方程为

$$
dp[i][j] = \min_{0 \leq x \leq k} dp[i - 1][k] + 2(x_i - r_{k + 1}) + b_{i, j}
$$

> 注意上上述式子只有 $b$ 与 $j$ 有关，且可以分离出来，所以我们完全可以维护一个前缀最小值和后缀最小值，然后 O(1) 的更新答案，从而 dp 部分复杂度 $O(n)$，所以最终复杂度 $O(n \log n)$

最终答案为 $dp[n][k]$, 其中 $k$ 为 节点 $n$ 后面的区间个数 
