# [Codeforces Global Round 16](https://codeforces.com/contest/1566)

## A

答案显然为: `s / (n - (n - 1) / 2)`

## B

直接贪心，看有几段 0，当然了答案不会超过 2

## C

这个也是贪心
- 注意到如果一列正好 0, 1 都有那么直接答案 +2，然后如果前面有 0 的列，那么答案再 +1
- 否则看两列的情况，两列都是 1，那么直接无视看作一列 1，如果两列都是 0，视作一列 0，并且答案 +1
- 如果两列不同，答案直接 +2
- 最后如果还有一列 0 在的话，答案 +1

## D

首先正常排序，然后就可以变成一行行的解决了，对于每一行，可以对下标先离散化一下，然后用树状数组更新结果，对于每一个如果两个值相等，肯定是编号小的放后面比较赚

## E

注意到我们每次割边之后，可以放在根上先暂时放着，然后我们就可以开心的割了，对每一个节点 u，它的儿子节点 v，如果 v 只有它自己，那它就必须跟 u 连在一起，否则他们就要分离，假设 u 有 x 个儿子最后跟它在一起(x > 0)，那么它对答案的贡献就为 $x - 1$