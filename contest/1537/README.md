## [Codeforces Round #726 (Div. 2)](https://codeforces.com/contest/1537)

挺生气的！太久没训练了，又开始蠢了，速战速决，大哥，别在那证半天了！

### A: 添加非负数使得使得平均数为 1

若 $s = n$，显然不用假，$s > n$ 加一个负数即可，否则加 $n - s$ 个 0

### B：trick 题

很容易想到在左上角和右下角搞一个即可，但是不自信，证了 5 分钟，很不应该

> 能不能急躁一点

### C：在保证首位差值最小的情况下，保证相邻两个是小于关系的个数最多

这个先排序，然后相邻的差值必然最小，然后找最小差值即可，我一开始还特判是否开始，结尾是。哎，吐了，然后以为 
`1 3 10` 的答案必须是 `1, 10, 3`(想多了)

然后这题我 hack 别人的代码，然后我 -50 吐了

### D：二人博弈

本来是我擅长的领域，结果想了老半天，想出了方案，结果呵呵了，代码逻辑某处写反了一下，然后以为自己推错了，然后打表找规律发现自己没推错吐了。（第一次打表，表打错了，贡献了一次 WA 我也是吐了）

> 以后遇到二人博弈先给我打表找规律再证明

首先 $n$ 为奇数则先手必输：它选的数设为 $k$(奇数)，所以 $n - k \neq 0$ 必然还是 $k$ 的倍数，所以后手也选 $k$ 即可。
若 $n = 2^k x, x > 1$，那么此时先手选 $x$ 即可变成奇数，就赢了。所以只剩下 $n = 2^k$ 的情况，注意到如果先手不选  $2^{k - 1}$，那么它必输，所以 $k$ 为奇数时必输，反之必赢。

### E：自增一次或者去掉最尾部的字符

我一开始以为是，后缀数组问题，然后去 copy 后缀数组的模板，没理解模板返回值，结果还以为模板除了问题，吐了。然后折腾了一会发现不对呀。后来发现你要的是 $s[0,\cdots, i]$ 比 $s[i + 1, \cdots]$ 小才行。因此 $s[i]$ 必然是小于等于 $s[0]$ 的，然后一直找即可。但是忘了特判 $s = aab$ 的情形会导致当前答案越界，把这个搞好了就过了


> 一个细节，我们可以存 i 的值而非答案，然后输出的时候取模就可以了

### F：想做的时候只有 17 分钟，读完题目没有思路就放弃了

> 此题其实可以不要求联通

注意到如果原图是二部图，那么分别对两边求和，如果和相同就必然可以。否则我们只需看这个图的点和是不是偶数即可
