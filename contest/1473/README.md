## [Educational Codeforces Round 102 (Rated for Div. 2)](https://codeforces.com/contest/1473)

### D：经典前缀后缀

前缀和的历史最大值和历史最小值是特别好求的。后缀和的呢，却不那么显然。考虑后缀的时候，我们实际上要考虑后缀对最后结果的贡献。比如最大值，我们需要看当前后缀是否大于 0，如果小于等于 0 就直接抛弃重新开始，否则就继续保存。最小值同理。

### E：经典最短路，去掉一个最长路，加上一个最短路

一条路径的权值定义为 $\sum w_{e_i} - \max e_i + \min e_i$，显然这等价于 $\min \sum (w_{e_i}) - w_{e_j} + w_{e_k}$。因此我们可以建图：比如原始边为 (u, v, w), 一个节点到了 4u 表示是原始的长度， 4u + 1 表示减去了某个边，4u + 2 表示加上了某条边，4u + 3 表示既加了也减了。

> 也可以不建成上述图，按照原始图建图，操作的时候再也可以，本质上一致更节省空间，代码稍微复杂一点。

### F：经典最大流（最小割）问题

题意：给定长为 n($1 \leq n \leq 3000$) 的数组 a($1 \leq a_i \leq 100$), b($-10^5 \leq b_i \leq 10^5$)，求 $\displaystyle \max_{i \in S} b_i$，其中集合 $S$ 满足若 $i \in S$，则任意 $0 \leq j < i$, 若 $a_i \equiv 0 \mod a_j$，那么 $j$ 也在 $S$ 中。

做法：设 $s = n$ 为源点，$t = n + 1$ 为汇点，如果 $b_i > 0$（则称 i 为正点，否则为负点），那么我们从源点 $s$ 到 $i$ 建一个容量为 $b_i$ 的边，反之我们就从 $i$ 到 $s$ 建一个容量为 $-b_i$ 的边。如果 $j < i$ 满足 $a_i \equiv 0 \mod a_j$，那么从 $j$ 到 $i$ 建一个容量为无穷大的边（一个必要的优化，直接这样建图，边太多了，根据这个性质的传递性，我们不妨找最后一个值为 $a_j$ 的点和 $i$ 相连）。
我们不妨先把所有正点全部放在 $S$ 中，然后求最小割即可，注意到满足性质的边容量是无限大的，因此我们必然会将这样的两个节点放在一起！