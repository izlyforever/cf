# [Codeforces Round #768 (Div. 2)](https://codeforces.com/contest/1631)

## A

首先两个 max 中必有一个是全部的最大值，然后相当于一个每个位置的最小值再取最大值和每个位置取最大值再取最大值的乘积

## B

> 我一开始还以为前面替换后面

首先把数组反序，然后找到第一个不一致的位置，然后倍增继续找知道结束

## C

注意到 $a \And (2^k - 1 - a) = 0$，因此对于任意 $0 < x < 2^k - 1$，我们可以这样配对

$(2^k - 1, x), (0, 2^k - 1 - x)$, 其它的全取 $(a, 2^k - 1 - a)$

如果 $x = 0$，那么全取 $(a, 2^k - 1 - a)$ 即可

如果 $x = 2^k - 1$ 可以取 $(2^k - 1, 2^k - 2), (1, 3), (2^k - 4, 0)$，然后其它的全取 $(a, 2^k - 1 - a)$。（注意此时 $k > 2$，否则无解）

## D

注意到只要整体在区间 $[x, y]$ 的个数 $z$ 满足 $z \geq n - z + k$ 即可分成 $k$ 个。于是我们枚举 $x$，用双指针即可知道 $y$ 的最小值。然后找出 $y - x$ 的最小值。就确定了 $x, y$，再贪心就可构造出 $k$ 端

## E

这题其实也挺简单的，但是我线段树一个符号写错了 debug 了半天没发现问题，给自己一个大嘴巴的。后面用 Xcode 才注意到

这个题的思路就是假设 $dp[i]$ 表示当前前缀的答案，那么假设 $l[a[i]]$ 表示值为 $a[i]$ 最左边出现的位置，那么

$$
dp[i] = \max(dp[l[a[i]], \max_{j = l[a[i]]}^i dp[j] + i - j - 1)
$$

所以我们可以定义一个 $= dp[i] - i$，那么状态转移就变成了

$$
dp[i] = \max(dp[l[a[i]], i - 1 + \max_{j = l[a[i]]}^i f[j])
$$

所以搞两个线段树即可，其实搞一个就行了