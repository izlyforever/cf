# [Codeforces Global Round 19](https://codeforces.com/contest/1637)

## A

只要前面有数字比自己大，就可行

## B

直接暴力，枚举后缀，然后令 $dp[i]$ 表示的前缀最大值，自然

$dp[i] = \max_{j = 1}^{i - 1} dp[j] + 1 + mex(a[j + 1] \cdots a[i])$

## C

- $2k$ 总是会转移出去的，然后转移到哪里是无所谓的，需要的次数为 $k$
- $2m + 1$ 转移出去，需要一个 $2k$ 提供支持，让他变成 $2m + 2$，这一次不算它的，因此它需要 $m + 1$ 次

对可行性判断的时候发现，如果 $n = 3$，那么可行当且仅当 $a[1]$ 为偶数。否则当且仅当不全为 1

## D

注意到

$$
\sum_{i = 1}^n \sum_{j = i + 1}^n (a_i + a_j)^2 = (\sum_{i = 1}^n a_i)^2 + (n - 2) \sum_{i = 1}^n a_i^2
$$

所以原问题就转化成分两组，然后让 $\sum_{i = 1}^n a'_i$ 和 $\sum_{i = 1}^n b'_i$ 差值最小

处理的时候可以先减去最小值，就变成了裸 0-1 背包

## E

按照出现次数分组，然后每组单独处理，任选两组处理，显然组数不超过 $\sqrt{n}$，因此整体复杂度为 $O(n \log n + m)$
