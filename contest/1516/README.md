
## [Codeforces Round #717 (Div. 2)](https://codeforces.com/contest/1516)

[mohammedehab2002](https://codeforces.com/profile/mohammedehab2002) 的连续第二场，相对第一次质量更高，不只是单纯的数论

### B: 没注意**最多**两个，贡献了一次 WA

如果最后只有两个，那么必然要求所有数异或和 $r = 0$ 0，如果是 3 个，每一个异或和部分都是 r。然后这正好是奇偶的情况。所以 $r = 0$ 直接就可以，否则 $r \neq 0$，那么我们碰到异或前缀和为 $r$ 就删掉并计数一次，然后看最终结果是不是 r，且计数次数大于 1

> 很有意思的问题

### C：背包 + 奇偶性

### D: 经典问题：区间划分成子区间，多次查询

合理区间等价于同一区间不能有公共的素因子。所以如果不是多次查询，我们直接贪心就能做了。多次查询我搞不了，就以为要莫队，结果学了莫队也不能转移。后来才知道是倍增算法！！

做法：预处理 N 以内所有素数，然后处理出前 N 个数的所有素因子（不算重），再 `dp[i]` 表示能到达右边的最远位置，即 $[i, dp[i])$ 是以 i 开头最大的合理区间。那么 dp 的时候从右往左转移即可。dp[i] 定义好了，我们就朴素倍增即可。倍增的最大高度显然不会超过 log n，因此算法复杂度为 $O(N \log N)$。


### E: 经典问题：经过 k 次互换操作，最终得到的不同排列的数量

首先把它简化成，有多少个长度为 n 排列正好经过 k 次互换操作能变成有序的记作 $DP[n][k]$，那么状态转移为
$$
dp[i][j] = dp[i - 1][j] + (n - 1) \cdot dp[i - 1][j - 1]
$$

最终的答案是 $dp[n][j] + dp[n - 2][j] + \cdots$。复杂度 $O(n k)$，并且我们可以优化空间为 $O(1)$ 的。但是时间复杂度还是过不了，因此我们需要寻找其它做法：

注意到 $k$ 次互换操作后，最多有 $2k$ 个位置发生了改变。

我们用生成函数 $\displaystyle f_n = \sum_{k \geq 0} dp[n][k] x^k$，注意 $f_1 = 1, f_2 = 1 + x$

$$
f(n) = \prod_{i = 0}^{n - 1} (1 + i x)
$$

然后就转换成计算这个函数的次数不高于 k 的系数了。分治做法：
$L = \sum_{i = l}^{m - 1}(1 + ix), R = \sum_{i = m}^{r - 1} (1 + ix)$ 所以可以借助于 $L$ 来计算 $R$。完全可以类似于 powMod 的计算。

[hugin](https://codeforces.com/blog/entry/89846?#comment-783233) 的[代码实现](https://codeforces.com/contest/1516/submission/113874644)

另外的做法见我的 [codeforces 上的评论](https://codeforces.com/blog/entry/89846?#comment-783243) 以及[我的代码实现](https://codeforces.com/contest/1516/submission/113886543)
