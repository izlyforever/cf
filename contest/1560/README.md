# [Codeforces Round #739 (Div. 3)](https://codeforces.com/contest/1560)

## A

直接暴力即可

## B

不妨设 $a < b$, 那么 $d = b - a$ 就是 $n$ 的一半，并且显然 $d \gep a$

## C

开根即可

## D

对每一个 2 的幂的字符串和原始字符串对比即可

## E

根据每个字符从后往前出现的先后顺序得到删除的顺序，再根据出现的频率获取每次的长度，再根据删除来判断是否一致

## F

若 $k \leq 2$，那么直接暴力所有情况，然后再 `lower_bound` 即可

对于一般的情况，我们可以从前到后贪心。具体的说就是

如果当前不同数字超过了 $k$ 个，那么我们就找一个比他大的出现过的，然后后面都填最小的。如果没比他大的，那就加一再处理一次
