# [Codeforces Round #772 (Div. 2)](https://codeforces.com/contest/1635)

## A

所有数的或

## B

注意到所有局部最大值变成左右的最大值即可消除

又注意到如果正好两个局部最大值相隔为 2，那么可以把中间的值变成它们的最大值，是更优策略

## C

注意到有方案当且仅当 $a[n] \geq \max(a[n - 1], 0)$

我读题读成了要求次数最少（如果是这样这么解，待补），想了半天吐了。

## D

我们可以按照位数 DP 解决，先对所有数排序，然后看后面的数能否由前面数生成，如果可以就忽略，否则加进来。然后我们再逐位操作 dp 即可

> 实际上 $p < 1e9$ 也可以利用 fib 来做: <https://codeforces.com/blog/entry/100153?#comment-888653>


## F

首先注意到题目中说 $x_i < x_{i + 1}$，根据题解，定义 $L_i, R_i$ 分别为最有最接近 $i$ 且不大于满足 $w[i] \geq w[j]$ 的位置（可以用单调栈 $O(n)$ 求出），然后最优解必然在 $(L_i, i)$ 和 $(i, R_i)$ 中某一个位置取到，然后使用 [评论所述的技巧](https://codeforces.com/blog/entry/100153?#comment-888831) 离线，按照左坐标分组，然后从右向左依次把这些组添加进来
