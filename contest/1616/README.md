# [Good Bye 2021: 2022 is NEAR](https://codeforces.com/contest/1616)

## A

贪心即可，本身有就插入相反数

## B

仅需看 `s[0]` 是否等于 `s[1]`（如果有的话），如果等于，那么就是答案 `s[0]s[0]`，否则就是最长单调不增的连续子串

## C

枚举两个位置，然后看其它的是否在此等差数列中

## D

注意到 $a_l + a_{l+1} + \ldots + a_r \geq x \cdot (r - l + 1)$ 等价于 $a'_l + \cdots + a'_r \geq 0$，其中 $a'_i = a_i - x$。简化后，我们发现（不是那么容易其实）

- 如果当前的和大于等于 0，那么这个和，应该和当前值取最小值（想想为什么）
- 如果当前的和小于 0 时，如果个数为 1，那么继续。否则必然要删点，其实这时就应该删除当前点！（这是因为上一个策略）

至此我们的逻辑就简洁了，直接写即可

## E

显然，对于当前位置 $i$，我们只要把一个 `i` 后面的且比 `b[i]` 移动到 `i` 位置上即可。那么这个移动的过程中，会导致，这个区间的所有位置往后移动了 1。所以要做区间加。所以可以用增强版树状数组，或者线段树

> 注意到对于每个字符，它们的相对位置（在我左边的不可能去我右边）是不可能改变的！



