# [Good Bye 2021: 2022 is NEAR](https://codeforces.com/contest/1616)

## A

贪心即可，本身有就插入相反数

## B

仅需看 `s[0]` 是否等于 `s[1]`（如果有的话），如果等于，那么就是答案 `s[0]s[0]`，否则就是最长单调不增的连续子串

## C

枚举两个位置，然后看其它的是否在此等差数列中

## D

注意到 $a_l + a_{l+1} + \ldots + a_r \geq x \cdot (r - l + 1)$ 等价于 $a'_l + \cdots + a'_r \geq 0$，其中 $a'_i = a_i - x$。简化后，我们发现（不是那么容易其实）

- 如果当前的和大于等于 0，那么这个和，应该和当前值取最小值（想想为什么）
- 如果当前的和小于 0 时，如果个数为 1，那么继续。否则必然要删点，其实这时就应该删除当前点！（这是因为上一个策略）

至此我们的逻辑就简洁了，直接写即可

## E

显然，对于当前位置 $i$，我们只要把一个 `i` 后面的且比 `b[i]` 移动到 `i` 位置上即可。那么这个移动的过程中，会导致，这个区间的所有位置往后移动了 1。所以要做区间加。所以可以用增强版树状数组，或者线段树

> 注意到对于每个字符，它们的相对位置（在我左边的不可能去我右边）是不可能改变的！

- 然而，用加强版树状数组 TLE 了，其实我们应该存位置的差值，这样就很好更新了，复杂度 $26 n \log n$
- 但其实可以做的更优秀，即记录被移动到前面去的点的位置，这样看后面的这样的点有多少个，就知道自己被移动到多前面的地方了 $n \log n$

## H

看 [jiangly 的代码](https://codeforces.com/contest/1616/submission/141136550)，就懂了

首先原题目与 $a$ 的次序无关，我们不妨先排序简化问题。假设 $2^{k - 1} \leq x < 2^{k}$，那么 $a, b$ 能在一起出现的前提是 $\lfloor \frac{a}{2^k} \rfloor = \lfloor \frac{b}{2^k} \rfloor$。由于我们排过序了，所以可以一组一组的来。对于每一组，分成在 第 $k$ 位是 0 还是 1 分成两边，然后在根据 $x$ 的当前为是 0 还是 1 分类成两个区间 `[l, m)` 和 `[m, r)`。

``` cpp
// 表示 [l1, r1) 和 [l2, r2) 中任意各取一个数 x1, x2，都满足 (x1 ^ x2 ^ x) >> k = 1
// 且任取两个数 x1, x2 都满足 (x1 ^ x2 ^ x) >> (k + 1) = 0 的前提下的允许空的答案数
work = [&](int l1, int r1, int l2, int r2, int k) -> int {};
```
