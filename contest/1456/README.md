## [Codeforces Round #687 (Div. 1, based on Technocup 2021 Elimination Round 2)](https://codeforces.com/contest/1456/)

本场我只能做 AB 两题，但是我可以做的快，做的优雅的，可是我没有！首次比赛被 hack

### A：经典 DP

题意：给定 0-1 字符串，需要让 $p, p + k, \cdots$ 位置都变成 1，每变一个位代价是 x，或者删除最开始的字符，这样做代价是 y。

做法：我们可以把字符串反过来，然后答案就是 `a[n - p]`，状态转移：不删字符的情况下，`a[i]` 为 $s[i], s[i - k], \cdots$ 中 0 的个数。$a[i] = \min_{1 \leq t \leq i}(a[i], a[i - t] + t * y)$，所以我们可以将 `a[i] - iy` 添加到 set 中，然后最小值加上 当前的 `iy` 就是真实的最小值。

> 很早就想到了做法，实现的时候写的太急了，分析不过细致，把自己整吐了。

### B：XOR 问题

题意：给定一个非降的序列，可以将相邻的两个变成它们的异或值，能否在最小的步数上，将这个序列不满足非降条件。

做法：注意到，如果有三个相邻的数最高位一致，那么答案必然是 1，因此本质上我们只需考虑 n = 60 的情况，所以，随便写就能过（所以我写的特别随便，然后被人 hack 了，我真的服了自己！）