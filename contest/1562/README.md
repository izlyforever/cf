# [Codeforces Round #741 (Div. 2)](https://codeforces.com/contest/1562)

## A

显然能取到 $b = \lfloor \frac{r + 1}{2} \rfloor$, a = $2b - 1$ 是最佳的，否则答案就是 $l, r$ 最佳

## B

- 出现 $1, 4, 6, 8, 9$ 必然长度为 1
- 否则，出现 xx 必然是 xx
- 否则，若 $2, 5$ 出现在非首部，那么 $x2$ 或者 $x5$ 即可
- 否则，此时删除 3（最多出现 1 次）
- 此时，若 $2, 5$ 出现在首部，随便找一个（必然为 $1, 7$ 中的一个）
- 最后，随便找长度为 3 的即为答案

## C

注意到如果字符中有 0，那么就可以根据 0 在前半段还是后半段选择（注意让 t 的长度大于 w），否则全为 1，取两个长度相等的段即可（注意要不一样）

## D

注意到如果本来就为 0，啥都不用干，注意到如果 `r - l + 1` 即区间长度为奇数，那么我们肯定可以通过删除中间某个数，从而使得结果为 1。否则我们可以先删除尾部（也可以是头部，但是头部会更加麻烦，要调节符号）从而变成长度为奇数的情况

> 我一开始想删除尾部，后来因为输入输出的问题，我就先删除了头部，然后忘了调节符号，直接 debug 到爆炸

我们先算一下累计和，然后看 $a[l - 1], a[r]$ 是否相等。相等就结束，再看长度是否为奇数，不是就删最后一个变成奇数，下面假定长度为奇数。

对每一个位置，我们根据它贡献 + 还是贡献 - 分成两类，然后记住他们的前缀和，然后再根据

$\frac{a[r] - a[l - 1] + 1}{2} + a[l - 1]$ 的结果在何处，分两种情况找到对应的位置（注意位置应该落在 $[l, r]$

## E

~~直接 SA 后缀数组，然后根据 height 数组求解即可，可以做到 $O(n)$~~

我还以为求不同的子序列个数呢？原来是求给定的子串的最长递增序列长度

所以可以先给出每个子串的序号，然后直接跑 lcp 即可。复杂度 $O(n^2 \log n)$

题解的做法是：$O(n^2)$

注意到如果 $[l, r]$ 在这个最长的递增序列中，那么 $[l, n]$ 必然也在。然后新来一个字符那么就要考虑 $[l_2, n]$ 和它的最长公共前缀（这部分我们可以直接预处理出来）。然后最终 dp 就搞好了

dp 有两种策略，一种是按照位置 dp，另一个种按照 sa 的顺序 $dp$(常数会小不少)
