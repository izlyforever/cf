## [Codeforces Round #696 (Div. 2)](https://codeforces.com/contest/1474)

### C：乱搞题

> 一开始思路不清晰就写代码，写着发现有问题，被卡了挺长时间，导致 D 题差最后 10 分钟没有 debug 出一个小错误。

做法：从最大的开始找，然后删除对应的节点即可。初始值 x 必然是 a 中最大值和另一个值的和。分析好问题后再选取合适的 STL，我用的是 map，很多人用的是 multiset 


### D：相连同时减一

题意：每次可以同时使得相连两个数减 1，问是否能使得数组变成全 0。这个问题相当简单，因此换成，能否最多互换相连两个的值，使得原问题成立。

做法：原问题做法就是从左到右依次跑，如果跑出负数就不行，跑到最后不是 0 也不行。然后一开始我想错了，吃了两次 WA 之后，发现互换相邻两个之后原问题成立的前提是，从左到右跑和从右到左跑都不会出现负数。因此就保存左右两边跑的结果，然后只需考虑 4 个数的时候是否对就可以了。
