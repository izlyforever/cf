# [Codeforces Round #755 (Div. 2, based on Technocup 2022 Elimination Round 2)](https://codeforces.com/contest/1589)

## A

$u^ 2 - v^2 = (u + v)(u - v)$

## B

显然切成 $3 \times 1$ 或 $1 \times 3$ 最好

## C

排序比较即可

## D

我们可以找到最右端点，然后 3 次就可以了（2 次也可以，但是没必要）


## E

这是一道经典贪心问题，而且以前也见过类似的，但是每次都不会？有点搞，这次必须搞定（其实沉下心来慢慢推导公式也是可以做出来的）

按照题解的说法：首先定义数组 $c$ 为 $c_i$ 表示移除 $1, \cdots, i - 1$ 后，第 $i$ 个位置石头个数。所以  $c_0 = 0$, $c_i = a_i - c_{i - 1}$。所以 $[1, r]$ 能赢当且仅当 $c_r = 0, c_i \geq 0 \quad \forall 1 \leq i \leq r$。

现在我们分析做左端点为 $l$ 的情况，定义序列 $a^l = a_l, \cdots, a_n$, $a^l_i = a_{l + i - 1}$，同理我们可以对 $a^l$ 定义 $c^l$，从而 $[l, r]$ 能赢当且仅当 $c^l_{r - l + 1} = 0, c^l_i \geq 0 \quad \forall l \leq i \leq r - l + 1$。而注意到

$$
c^l_i = a^l_i - a^l_{i - 1} + \cdots + (-1)^{i - 1} a^l_1 = a_{l + i - 1} - a_{l + i - 2} + \cdots + (-1)^{i - 1} a_l = c_{l + i - 1} - (-1)^i c_{l - 1}
$$

因此 $c^l_i < 0$ 当且仅当 $c_{l + i - 1} < (-1)^i c_{l - 1}$，因此我们可以分奇偶，对每个 l 找到对应的 i。$c^l_i = 0$ 也是同理的，于是我们可以二分查找找到所有的合理的 $c^l_i = 0$ 的位置

感觉写的话老麻烦了，最后抄一下 jiangly 的代码

他的代码可以看出总让第一个系数为正，这样确实有很大的好处！做法其实就是先搞最右边的，然后看最左边剩下的值。

**按照jiangly 的做法**

$a_i$ 以 0 开始标号，定义 $s[0] = 0, s[i + 1] = \sum_{j = 0}^i (-1)^j a_j$. 那么显然 $[l, r)$ 等价于 $s[l] = s[r]$ 且对任意 $l < i < r$ 成立 $(s[i + 1] - s[l]) \cdot (-1)^i \geq 0$，因此若 $i$ 为偶数，只需满足 $s[l] \leq s[i + 1]$ 即可，若 $i$ 为奇数，只需满足 $s[l] \geq s[i + 1]$ 即可

那么我们可以先排序，就可以把所有与 $s[l]$ 相等的 $r$ 都找出来，并且它们是连续的。那么此时就给出了一个区间 [l, r)，对应的给出了一个递增的 $p_l, p_{l + 1} \cdots, p_{r - 1}$，然后一个个的看中间有没有断开，如果有就要重新开始，妙啊。注意到我们总是单调递增的。所以我们可以用一个 set 默认存下偶数点，然后逐步添加奇数点。

这种做法也太舒服了吧！ jiangly yyds
