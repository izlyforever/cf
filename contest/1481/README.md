## [Codeforces Round #699 (Div. 2)](https://codeforces.com/contest/1481)
 
### E：经典 DP

题意：每次从数列 a 中取出一个数放在尾部，使得相同的数字挨在一起，问最少需要的次数。

做法：首先反过来考虑，看最多能有多少数维持不动（一下子简单了不少，如果直接处理原问题，会要考虑移动顺序就很难考虑了）我们显然是从后往前好考虑一些，我们设 `dp[i]` 为 $[i, n]$ 中最多维持不动的数。我们考虑状态转移，我们可以删除第 i 个数，此时 `dp[i] = dp[i + 1]`，否则我们保留 $[i, n]$ 中所有值为 `a[i]` 的数，如果更进一步 $[1, i - 1]$ 中不再出现 `a[i]`，那么我们可以把最后一个出现 `a[i]` 后面的也拿到，反之不能拿到的原因是，前面的 `a[i]` 要删掉要放在后面，因此，最后一个 `a[i]` 后面什么都不能放。
