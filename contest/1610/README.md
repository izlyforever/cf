# [Codeforces Global Round 17](https://codeforces.com/contest/1610)

## A

比赛结束都没做掉？没有考虑 $m$ 和 $n$ 同为 1 时，无需加点。其它情况很好考虑，最多就是取左上角和左下角，或者左上角和右上角

## B

注意到收尾对比，首次发现不一致，那么只有替换其中一个才能合法，因此就相当于枚举两个数字即可

## C

这个可以根据结果二分答案，一开始以为是个 DP，想了一会发现二分答案+贪心十分好写

## D

找规律，首先单个奇数合理，单个偶数必不合理，后来思考了半天发现，

- 如果是奇数 $2k + 1$，则 $(2k + 1)x$ 是所有可能的值
- 如果是偶数 $2k$，则 $2k x + k$ 是所有可能的值

如果有奇数，那么总有解（考虑最大公约数），**以下不再考虑奇数**，假设有两个分别是 $2m, 2n$

$$
2m x + m + 2n y + n = 0
$$

有解当且仅当 $__builtin_ctz(m) = _builtin_ctz(n)$。然后就发现无论多少个偶数，只要 `__builtin_ctz` 最小的个数是奇数个就必然不行（根据二项式展开知道个数为 $2^{t_k - 1}$, 其中 $t_k$ 为 $__builtin_ctz = k$ 的个数。所以我们按照 `__builtin_ctz` 的值单调递增的往上找就可以了

## E

经典问题：注意若数组 $c(c_i \leq c_{i + 1})$ 是 terrible 的，那么它必然有长度为 3 的 terrible 子序列。这是因为若存在 $i > 2$ 使得 $c_{i + 1}  - c_i < c_i - c_1$，那么它就是 terrible 的，否则可以看出任意 $c_{i + 1} - c_i \geq c_i - c_j$，因此这个数列必然是 good 的。因此我们我们只需要找最长的满足 $c_{i + 1}  - c_i \geq c_i - c_1$ 的序列即可。显然选定了第一个数之后，后面的数每次越小越好。然后注意到和第一个数相同的数加进来不会影响是否为 good，因此尽量去加。

