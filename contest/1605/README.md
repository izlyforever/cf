# [Codeforces Round #754 (Div. 2)](https://codeforces.com/contest/1605)

## A

排序后，看公式是否是 3 的倍数即可。这是因为改变左右两边的值并不会改变两端的差值，因此只有改变前两个或者后两个，这样改变差距是 3

## B

从前往后找 1，从后往前找 0 即可

## C

- 若有 $aa$，答案为 2
- 否则若有 $axa$，答案为 3
- 否则若有 $axya$ 答案为 4
- 否则若有 $axxayya$ 答案为 7
- 否则为 -1

其中 $x, y$ 为 $b, c$ 的一个置换

## D

> 我点提交的时候，结束了？我服了

我一开始以为是博弈问题，后来发现其实是奇偶 + 贪心问题，并且总存在一种重新编号使得所有点本质上不互通，从而 Eikooc 怎么选都必赢。首先 $u \otimes v \leq \min(u, v)$ 等价于 `std::__lg(u) = std::__lg(v)`。我们可以先把树上的每个节点标记 0 和 1，使得相邻的点值各异。

然后考虑到二进制的特殊性，任何 `k = std::__lg(u)` $u$ 的个数不会超过其它个数的总和 + 1，因此这个数量不会超过当前标记为 0 的点和标记为 1 的点的最大值。然后我们把当前最多的全部丢进当前标记最多的哪一个，直到所有点都处理完

> 我一开始还以为是一个 树上 SG 问题（注意不是有向无环图的 SG 问题），但是这引入了一个标准 SG 问题！即使只有一棵树也好难分析啊

树上 DP 看每个点到其它点是否奇偶都兼备？

## E

直接待定系数法，把所有值求出来，然后就是算一下绝对值之和了，可以求一下前缀和，后缀和，然后二分查找，得到前缀和，后缀和之和
