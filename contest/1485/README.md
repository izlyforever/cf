## [Codeforces Round #701 (Div. 2)](https://codeforces.com/contest/1485)


### C：整除分块

题意：问满足 $\lfloor \frac{a}{b} \rfloor = a \mod b, 1 \leq a \leq x, 1 \leq b \leq y$ 的 $(a, b)$ 有多少对。

做法：上式等价于 $a = (\lfloor \frac{a}{b} \rfloor)(b + 1)$。所以 $a = (b + 1) n$ 且 $1 \leq n < b$。我们固定 b，则答案就是
$$
\sum_{b = 2}^{y} \min( \lfloor \frac{x}{b + 1} \rfloor, b - 1) = \sum_{b = 3}^{y + 1} \min( \lfloor \frac{x}{b} \rfloor, b - 2)
$$

然后整除分块即可。

### D：奇偶性问题

矩阵中原始元素小于等于 16，新元素需要时原来元素的倍数，且使得相邻元素的绝对值是一个非 0 四次方数。取一下 lcm 可以使得所有元素差值都为 0，然后这个四次方数可以取原来数的四次方（分奇偶）。

### E：经典 DP

给一个每个叶子节点深度都为 d 的有根树，从根开始有红蓝两个硬币，每轮
- 红色硬币选择到达某一个儿子节点
- 蓝色硬币选择移动到任何一个深度比自己大 1 的节点。
- 红蓝硬币可以互换位置

每一轮它们都能得到 $|a_r - a_b|$ 分，问最终移动到叶子节点时最高得分。

我们设 `dp[i]`：此轮结束红色节点在 i 节点位置，当前的最大得分。我们考虑状态转移

若此轮第二步结束时节点 i 上是红色硬币，那么 $dp[i] = dp[fa[i]] + \max_{dist[j] = dist[i]} |a_i - a_j|$（显然我们选择最小或者最大的 $a_j$）。反之我们需要最大化 $dp[fa[j]] + |a_j - a_i|$，因为我们需要最大化 $dp[fa[j]] + a_j$ 和 $dp[fa[j]] - a_j$。所以最终我们有一个 $O(n)$ 的算法。

### F：经典 DP

设 `dp[i][j]` 表示长度为 i 和为 j 的 hybrid 的个数。状态转移 `dp[i][j] -> dp[i + 1][j + b[i]]` 以及 `dp[i][j] -> dp[i + 1][b[i]]`。注意到 如果 $j = 0$ 就重复了。

我们利用水涨船高技术。每次操作 key 值都加 `b[i]` 那么转移 1 相当于没搞，转移 2 即使添加 key 为 0 的值，当前所有数的和。
