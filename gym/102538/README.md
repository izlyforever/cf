
## [300iq Contest 3](https://codeforces.com/gym/102538/)

### A. Airplane Cliques

题意：给定 $n$ 个节点的树，称两个节点是友好的，如果它们相连的边数不超过 $x$，问对任意 $1 \leq k \leq n$，有多少个元素个数为 $k$ 的集合，它们的点之间两两友好。其中 $1 \leq n \leq 300,000, 0 \leq x < n$，最终答案对 998244353 取模

> 看别人代码 200 多行，下次吧。

### C. Cells Blocking

题意：从 `(1, 1)` 到 `(n, m)` 只能往右或往下走格子，然后有些格子是不能走的，让你将 2 个能走的格子变得不能走，最后使得格子 `(1, 1)` 无法到达 `(n, m)`，问有多少种变的方式。 $1 \leq m, n \leq 3000$

做法，首先从任意点看它是否可以到 `(n, m)`，再看任意点是否可从 `(1, 1)` 到。然后就可以选择最下和最上的两个路径，显然路径重叠的点被移除的时候 `(1, 1)` 就无法到达 `(n, m)`（如果一开始就无法到达，答案自然就是 $\text{nm} \choose 2$, nm 表示可以走的格子数)，然后最下的路径不重叠的点，必然可以必须需要删去其中的一个，删除之后再让它走最下的路径，看它与最上路径的交点，交点个数就是可选点的个数。（一个小技巧就是一开始重叠的点标记一下，不再考虑，这样就不会重复计数了）

### E. Easy Win

> SG 函数-博弈问题

题意：有 $n$ 堆石子 $(a_1, \cdots, a_n)$（$a_i \leq n$），每次最少选 1 个，最多选 $x$ 个，最后谁没法选谁输，问对于所有的 $1 \leq x \leq n$，先手赢还是先手输。其中 $1 \leq n \leq 500,000$

首先，对每一个具体的 $x$ 答案是 $f(x) = (a_1 \mod x + 1) \oplus \cdots \oplus (a_n \mod x + 1)$ 是否为 0. 原因可参考之前的博文： {% post_link nimSgFunction SG 函数之取石子博弈 %}

为了优化时间复杂度，我们逐位计算 $f(x)$（即 计算 $f(x) \And 2^{j}$ 的值），首先我们对 $a_i$ 去重，用 $c_i = |\{t | a_t = i \}|$，令 $y = x + 1$。所以此时 $f(x) \And 2^{j} = \sum_{i = 1}^n c[i] (i \mod y) \mod 2 \cdot 2^{j}$
我们将 $[0, n]$ 分成 $[0, y), [y, 2y), \cdots, [ky, n]$，注意到若 $ky \leq a_i < (k + 1) y$，那么 $a_i \equiv a_i - ky \mod y$，如果对于每个区间我们在预处理的前提下，能在 $O(1)$ 时间复杂度计算出每个区间的值，那么我们就能在 $O(n \log^2 n)$ 解决此问题。注意到区间 $[ky, (k+1)y)$ 对答案的贡献是：那些满足 $ky \leq t < (k+1)y$，且 $t - ky$ 包含 j 位的那些 $c_t$ 的和。我们定义 $\displaystyle f_{i, j} = \sum_{x \geq i, (x - i) \And (2^j) \neq 0} c_x$，那么由于 $(x - i) \And 2^{j} \neq 0$ 等价于 $(x - i \pm 2^{j+1} \neq 0)$。所以有状态转移：
$$
f_{i, j} = f_{i + 2^{j + 1}} + \sum_{t = i + 2^{j}}^{i + 2 ^{j + 1} - 1} c_t
$$
然后区间 $[ky, (k+1)y)$ 对答案的贡献就是 $f_{ky, j} - f_{t, j} - \sum_{i = \min((k + 1)y, t - 2^{j})}^{t - 1} c_i$，其中 $t = ky + \lfloor \frac{y}{2^{j + 1}} \rfloor$ 是不小于 $(k + 1) y$ 且与 $ky$ 模 $2^{j + 1}$ 次数最小的值。后面那个求和是因为那部分的和中 $i - ky$ 必然有 $j$ 位。搞定！

> 下面代码并不完全和上面解释一致，是因为我们值关心每一个位置是否为 0，用加减不方便，直接异或就行，也就是说其实下面很多 `int` 都可以换成 `bool`，不过 `std::vector<bool>` 不是 bool 型的向量，用起来不方便就没这么做了。


### I. Ignore Submasks

> 本场最简单的一题

题意：给定序列 $a_1, \cdots, a_n$ （$0 \leq a_i < 2^k$），记 $f(x)$ 为使得 $a_i \And x \neq a_i$ 的最小的 $i$，如果没有就为 0，求 $\sum_{i = 0}^{2^k - 1} f(i)$，对答案取模 998244353，其中 $1 \leq n \leq 100, 1 \leq k \leq 60$

做法：相当于一开始有 $k$ 个位是自由的，假设当前还有 $r$ 个位是自由的，$a_i$ 占有其中 c 个自由位，然后其它的自由位随便取，所以它对结果的贡献就是 $(2^r - 1) \cdot 2^{k - r} \cdot i$，注意 $k \leq 60$，很多地方记得加 `ll`。
